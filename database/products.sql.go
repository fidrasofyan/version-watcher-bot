// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: products.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getProductById = `-- name: GetProductById :one
SELECT id, name, label, category, api_url, created_at
FROM products WHERE id = $1 LIMIT 1
`

type GetProductByIdRow struct {
	ID        int32
	Name      string
	Label     string
	Category  string
	ApiUrl    string
	CreatedAt pgtype.Timestamp
}

func (q *Queries) GetProductById(ctx context.Context, id int32) (*GetProductByIdRow, error) {
	row := q.db.QueryRow(ctx, getProductById, id)
	var i GetProductByIdRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Label,
		&i.Category,
		&i.ApiUrl,
		&i.CreatedAt,
	)
	return &i, err
}

const getProductsByLabel = `-- name: GetProductsByLabel :many
SELECT id, name, label, api_url
FROM products 
WHERE label ILIKE $1 
ORDER BY label ASC NULLS LAST
LIMIT 100
`

type GetProductsByLabelRow struct {
	ID     int32
	Name   string
	Label  string
	ApiUrl string
}

func (q *Queries) GetProductsByLabel(ctx context.Context, label string) ([]*GetProductsByLabelRow, error) {
	rows, err := q.db.Query(ctx, getProductsByLabel, label)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetProductsByLabelRow{}
	for rows.Next() {
		var i GetProductsByLabelRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Label,
			&i.ApiUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsWithNewReleases = `-- name: GetProductsWithNewReleases :many
SELECT 
  p.id AS product_id,
  p.label AS product_label, 
  p.eol_url AS product_eol_url,
  jsonb_agg(
    jsonb_build_object(
      'release_label', pv.release_label,
      'version', pv.version,
      'version_release_date', pv.version_release_date,
      'version_release_link', pv.version_release_link
    )
  ) AS product_versions
FROM products p
JOIN LATERAL (
  SELECT pv.release_label, pv.version, pv.version_release_date, pv.version_release_link
  FROM product_versions pv
  WHERE pv.created_at = $1
  AND pv.product_id = p.id
  ORDER BY pv.version_release_date DESC NULLS LAST, pv.release_date DESC NULLS LAST
  LIMIT 3
) pv ON true
WHERE p.id = ANY($2::int[])
GROUP BY p.id
ORDER BY p.label ASC NULLS LAST
`

type GetProductsWithNewReleasesParams struct {
	CreatedAt pgtype.Timestamp
	Column2   []int32
}

type GetProductsWithNewReleasesRow struct {
	ProductID       int32
	ProductLabel    string
	ProductEolUrl   string
	ProductVersions []byte
}

func (q *Queries) GetProductsWithNewReleases(ctx context.Context, arg *GetProductsWithNewReleasesParams) ([]*GetProductsWithNewReleasesRow, error) {
	rows, err := q.db.Query(ctx, getProductsWithNewReleases, arg.CreatedAt, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetProductsWithNewReleasesRow{}
	for rows.Next() {
		var i GetProductsWithNewReleasesRow
		if err := rows.Scan(
			&i.ProductID,
			&i.ProductLabel,
			&i.ProductEolUrl,
			&i.ProductVersions,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWatchedProductByName = `-- name: GetWatchedProductByName :one
SELECT p.id, p.label
FROM products p
INNER JOIN watch_lists wl ON wl.product_id = p.id
WHERE p.name = $1
AND wl.chat_id = $2
LIMIT 1
`

type GetWatchedProductByNameParams struct {
	Name   string
	ChatID int64
}

type GetWatchedProductByNameRow struct {
	ID    int32
	Label string
}

func (q *Queries) GetWatchedProductByName(ctx context.Context, arg *GetWatchedProductByNameParams) (*GetWatchedProductByNameRow, error) {
	row := q.db.QueryRow(ctx, getWatchedProductByName, arg.Name, arg.ChatID)
	var i GetWatchedProductByNameRow
	err := row.Scan(&i.ID, &i.Label)
	return &i, err
}

const getWatchedProducts = `-- name: GetWatchedProducts :many
SELECT products.id, products.name, MIN(products.api_url) AS api_url
FROM products
INNER JOIN watch_lists ON watch_lists.product_id = products.id
GROUP BY products.id
`

type GetWatchedProductsRow struct {
	ID     int32
	Name   string
	ApiUrl interface{}
}

func (q *Queries) GetWatchedProducts(ctx context.Context) ([]*GetWatchedProductsRow, error) {
	rows, err := q.db.Query(ctx, getWatchedProducts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetWatchedProductsRow{}
	for rows.Next() {
		var i GetWatchedProductsRow
		if err := rows.Scan(&i.ID, &i.Name, &i.ApiUrl); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertProduct = `-- name: UpsertProduct :exec
INSERT INTO products (name, label, category, api_url, eol_url, created_at) 
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT(name) DO UPDATE SET 
  name = excluded.name,
  label = excluded.label,
  category = excluded.category,
  api_url = excluded.api_url, 
  eol_url = excluded.eol_url,
  updated_at = excluded.created_at
`

type UpsertProductParams struct {
	Name      string
	Label     string
	Category  string
	ApiUrl    string
	EolUrl    string
	CreatedAt pgtype.Timestamp
}

func (q *Queries) UpsertProduct(ctx context.Context, arg *UpsertProductParams) error {
	_, err := q.db.Exec(ctx, upsertProduct,
		arg.Name,
		arg.Label,
		arg.Category,
		arg.ApiUrl,
		arg.EolUrl,
		arg.CreatedAt,
	)
	return err
}
