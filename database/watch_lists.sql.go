// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: watch_lists.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createWatchList = `-- name: CreateWatchList :one
INSERT INTO watch_lists (chat_id, product_id, created_at) 
VALUES ($1, $2, $3) 
RETURNING id, chat_id, product_id, created_at
`

type CreateWatchListParams struct {
	ChatID    int64
	ProductID int32
	CreatedAt pgtype.Timestamp
}

func (q *Queries) CreateWatchList(ctx context.Context, arg *CreateWatchListParams) (*WatchList, error) {
	row := q.db.QueryRow(ctx, createWatchList, arg.ChatID, arg.ProductID, arg.CreatedAt)
	var i WatchList
	err := row.Scan(
		&i.ID,
		&i.ChatID,
		&i.ProductID,
		&i.CreatedAt,
	)
	return &i, err
}

const deleteWatchList = `-- name: DeleteWatchList :exec
DELETE FROM watch_lists 
WHERE chat_id = $1 
AND product_id = $2
`

type DeleteWatchListParams struct {
	ChatID    int64
	ProductID int32
}

func (q *Queries) DeleteWatchList(ctx context.Context, arg *DeleteWatchListParams) error {
	_, err := q.db.Exec(ctx, deleteWatchList, arg.ChatID, arg.ProductID)
	return err
}

const getWatchList = `-- name: GetWatchList :many
SELECT 
  p.name AS product_name, 
  p.label AS product_label
FROM watch_lists wl
JOIN products p ON wl.product_id = p.id
WHERE wl.chat_id = $1
ORDER BY p.name ASC NULLS LAST
`

type GetWatchListRow struct {
	ProductName  string
	ProductLabel string
}

func (q *Queries) GetWatchList(ctx context.Context, chatID int64) ([]*GetWatchListRow, error) {
	rows, err := q.db.Query(ctx, getWatchList, chatID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetWatchListRow{}
	for rows.Next() {
		var i GetWatchListRow
		if err := rows.Scan(&i.ProductName, &i.ProductLabel); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWatchListsGroupedByChat = `-- name: GetWatchListsGroupedByChat :many
SELECT
  chat_id,
  json_agg(DISTINCT product_id) AS product_ids
FROM watch_lists
GROUP BY chat_id
`

type GetWatchListsGroupedByChatRow struct {
	ChatID     int64
	ProductIds []byte
}

func (q *Queries) GetWatchListsGroupedByChat(ctx context.Context) ([]*GetWatchListsGroupedByChatRow, error) {
	rows, err := q.db.Query(ctx, getWatchListsGroupedByChat)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetWatchListsGroupedByChatRow{}
	for rows.Next() {
		var i GetWatchListsGroupedByChatRow
		if err := rows.Scan(&i.ChatID, &i.ProductIds); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWatchListsWithProductVersions = `-- name: GetWatchListsWithProductVersions :many
SELECT 
  p.id AS product_id,
  p.label AS product_label,
  p.eol_url AS product_eol_url,
  json_agg(
    json_build_object(
      'release_label', pv.release_label,
      'version', pv.version,
      'version_release_date', pv.version_release_date,
      'version_release_link', pv.version_release_link
    )
  ) AS product_versions
FROM watch_lists wl
JOIN products p ON wl.product_id = p.id
LEFT JOIN LATERAL (
  SELECT release_label, version, version_release_date, version_release_link
  FROM product_versions
  WHERE product_id = p.id
  ORDER BY version_release_date DESC NULLS LAST, release_date DESC NULLS LAST
  LIMIT 1
) pv ON true
WHERE wl.chat_id = $1
GROUP BY p.id
ORDER BY p.name ASC NULLS LAST
`

type GetWatchListsWithProductVersionsRow struct {
	ProductID       int32
	ProductLabel    string
	ProductEolUrl   string
	ProductVersions []byte
}

func (q *Queries) GetWatchListsWithProductVersions(ctx context.Context, chatID int64) ([]*GetWatchListsWithProductVersionsRow, error) {
	rows, err := q.db.Query(ctx, getWatchListsWithProductVersions, chatID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetWatchListsWithProductVersionsRow{}
	for rows.Next() {
		var i GetWatchListsWithProductVersionsRow
		if err := rows.Scan(
			&i.ProductID,
			&i.ProductLabel,
			&i.ProductEolUrl,
			&i.ProductVersions,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isWatchListExists = `-- name: IsWatchListExists :one
SELECT EXISTS(
SELECT 1 FROM watch_lists 
WHERE chat_id = $1 AND product_id = $2
LIMIT 1)
`

type IsWatchListExistsParams struct {
	ChatID    int64
	ProductID int32
}

func (q *Queries) IsWatchListExists(ctx context.Context, arg *IsWatchListExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, isWatchListExists, arg.ChatID, arg.ProductID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
