// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: watch_lists.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createWatchList = `-- name: CreateWatchList :one
INSERT INTO watch_lists (chat_id, product_id, created_at) 
VALUES ($1, $2, $3) 
RETURNING id, chat_id, product_id, created_at
`

type CreateWatchListParams struct {
	ChatID    int64
	ProductID int32
	CreatedAt pgtype.Timestamp
}

func (q *Queries) CreateWatchList(ctx context.Context, arg *CreateWatchListParams) (*WatchList, error) {
	row := q.db.QueryRow(ctx, createWatchList, arg.ChatID, arg.ProductID, arg.CreatedAt)
	var i WatchList
	err := row.Scan(
		&i.ID,
		&i.ChatID,
		&i.ProductID,
		&i.CreatedAt,
	)
	return &i, err
}

const getWatchLists = `-- name: GetWatchLists :many
SELECT 
  p.label AS product_label,
  jsonb_agg(
    jsonb_build_object(
      'release_label', pv.release_label,
      'version', pv.version,
      'version_release_date', pv.version_release_date,
      'version_release_link', pv.version_release_link
    )
  ) AS product_versions
FROM watch_lists wl
JOIN products p ON wl.product_id = p.id
JOIN LATERAL (
  SELECT release_label, version, version_release_date, version_release_link
  FROM product_versions
  WHERE product_id = p.id
  ORDER BY version_release_date DESC NULLS LAST, release_date DESC NULLS LAST
  LIMIT 1
) pv ON true
WHERE wl.chat_id = $1
GROUP BY p.label
ORDER BY p.label ASC NULLS LAST
`

type GetWatchListsRow struct {
	ProductLabel    string
	ProductVersions []byte
}

func (q *Queries) GetWatchLists(ctx context.Context, chatID int64) ([]*GetWatchListsRow, error) {
	rows, err := q.db.Query(ctx, getWatchLists, chatID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetWatchListsRow{}
	for rows.Next() {
		var i GetWatchListsRow
		if err := rows.Scan(&i.ProductLabel, &i.ProductVersions); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWatchListsGroupedByChat = `-- name: GetWatchListsGroupedByChat :many
SELECT
  chat_id,
  json_agg(DISTINCT product_id) AS product_ids
FROM watch_lists
GROUP BY chat_id
`

type GetWatchListsGroupedByChatRow struct {
	ChatID     int64
	ProductIds []byte
}

func (q *Queries) GetWatchListsGroupedByChat(ctx context.Context) ([]*GetWatchListsGroupedByChatRow, error) {
	rows, err := q.db.Query(ctx, getWatchListsGroupedByChat)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetWatchListsGroupedByChatRow{}
	for rows.Next() {
		var i GetWatchListsGroupedByChatRow
		if err := rows.Scan(&i.ChatID, &i.ProductIds); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isWatchListExists = `-- name: IsWatchListExists :one
SELECT EXISTS(
SELECT 1 FROM watch_lists 
WHERE chat_id = $1 AND product_id = $2
LIMIT 1)
`

type IsWatchListExistsParams struct {
	ChatID    int64
	ProductID int32
}

func (q *Queries) IsWatchListExists(ctx context.Context, arg *IsWatchListExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, isWatchListExists, arg.ChatID, arg.ProductID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
